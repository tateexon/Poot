#version 450

layout(local_size_x = 16, local_size_y = 16) in;

// Coordinates passed as uniform
layout(set = 0, binding = 0) uniform UBO {
    vec2 coordinates;
} ubo;

// Output heightmap buffer
layout(set = 0, binding = 1) buffer Heightmap {
    float data[];
} heightmap;

//
//  Wombat
//  An efficient texture-free GLSL procedural noise library
//  Source: https://github.com/BrianSharpe/Wombat
//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib
//
//  I'm not one for copyrights.  Use the code however you wish.
//  All I ask is that credit be given back to the blog or myself when appropriate.
//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)
//  Thanks!
//
//  Brian Sharpe
//  brisharpe CIRCLE_A yahoo DOT com
//  http://briansharpe.wordpress.com
//  https://github.com/BrianSharpe
//

//
//  Perlin Noise 2D
//  Return value range of -1.0->1.0
//
float Perlin2D( vec2 P )
{

    // establish our grid cell and unit position
    vec2 Pi = floor(P);
    vec4 Pf_Pfmin1 = P.xyxy - vec4( Pi, Pi + 1.0 );

    // calculate the hash
    vec4 Pt = vec4( Pi.xy, Pi.xy + 1.0 );
    Pt = Pt - floor(Pt * ( 1.0 / 71.0 )) * 71.0;
    Pt += vec2( 26.0, 161.0 ).xyxy;
    Pt *= Pt;
    Pt = Pt.xzxz * Pt.yyww;
    vec4 hash_x = fract( Pt * ( 1.0 / 951.135664 ) );
    vec4 hash_y = fract( Pt * ( 1.0 / 642.949883 ) );

    // calculate the gradient results
    vec4 grad_x = hash_x - 0.49999;
    vec4 grad_y = hash_y - 0.49999;
    vec4 grad_results = inversesqrt( grad_x * grad_x + grad_y * grad_y ) * ( grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww );

    // Classic Perlin Interpolation
    grad_results *= 1.4142135623730950488016887242097;  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.5)
    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);
    vec4 blend2 = vec4( blend, vec2( 1.0 - blend ) );
    return dot( grad_results, blend2.zxzx * blend2.wwyy );
}

void main() {
    uvec2 id = gl_GlobalInvocationID.xy;

    float xx = id.x;
    if (ubo.coordinates.x != 0) {
        xx = id.x / ubo.coordinates.x;
    }

    float yy = id.y;
    if (ubo.coordinates.y != 0) {
        yy = id.y / ubo.coordinates.y;
    }

    vec2 uv = vec2(xx, yy);

    if (uv.x == 0.0) {
        uv.x += 0.0001;  // Small perturbation
    }

    if (uv.y == 0.0) {
        uv.y += 0.0001;  // Small perturbation
    }


    // Compute Perlin noise or other function using uv
    float value = Perlin2D(uv); // Assuming you have a Perlin2D function in the shader

    heightmap.data[id.y * 1024 + id.x] = value;
}
